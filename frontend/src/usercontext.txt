# ZeroLag – Frontend-Only Prototype

This file is the **single source of truth** for the ZeroLag frontend-only prototype.
Assume **no prior context**. Do **not** improvise architecture, libraries, or behavior beyond what is defined here.

The goal is to build a client-side web app that:

* Connects directly to **Binance USDT-M Futures** REST + WebSocket APIs from the browser
* Computes all metrics and rankings **locally in the client**
* Renders a **grid of mini candlestick charts** for the top futures symbols
* Uses a clean, minimal dark UI with high performance
* Has a **Shift-based ruler tool** for precise measurements
* Is structured so a backend can be added later without major refactor

---

## 1. Tech Stack and Global Rules ✅

### 1.1 Tech Stack (fixed) ✅

* **Framework:** React 18
* **Language:** TypeScript
* **Bundler/Dev Tooling:** Vite
* **State Management:** Zustand (global store)
* **Styling:** Tailwind CSS (with a small set of custom CSS variables for colors)
* **Charting:** uPlot (canvas-based)
* **Network:** native `fetch` + native `WebSocket` (no Axios)

Do **not** introduce other state managers, other chart libraries, CSS frameworks, or utility libraries unless explicitly required for uPlot integration.

### 1.2 Project Layout ✅

Single repo, frontend-only:

```text
zerolag-frontend/
  src/
    core/
      types.ts          // app/shared types (enums, interfaces)
      metrics.ts        // pure metric computation functions
      ranking.ts        // pure functions that compute sorted lists from metrics
      intervals.ts      // constants and helpers for time windows and intervals

    data/
      binanceRest.ts    // REST calls to Binance Futures
      binanceWs.ts      // WebSocket connection & stream management
      clientProvider.ts // ClientBinanceProvider implementing DataProvider
      clientEngine.ts   // ClientMetricsEngine orchestrating data + metrics

    state/
      useZeroLagStore.ts // Zustand store for global app state

    components/
      AppShell.tsx
      layout/
        TopBar.tsx
      controls/
        SortSelector.tsx
        IntervalSelector.tsx
        CountSelector.tsx
      grid/
        ChartGrid.tsx
        ChartCell.tsx
        ChartSkeleton.tsx
      focus/
        FocusPanel.tsx
      charts/
        TimeSeriesCandleChart.tsx // uPlot wrapper

    index.css           // Tailwind base + custom theme
    main.tsx            // React entry
```

Folder names and file names **must** follow this structure unless later updated in this context file.

---

## 2. Functional Scope – MVP ✅

### 2.1 Market Coverage ✅

* **Only Binance USDT-M Futures** are supported in this prototype.
* Spot, COIN-M futures, options, and other venues are **out of scope**.

### 2.2 User Controls ✅

Available controls in the **Top Bar**:

1. **Sort (SortMode)**

   * `range_5m`   – highest 5-minute price range
   * `range_15m`  – highest 15-minute price range
   * `range_1h`   – highest 1-hour price range
   * `range_4h`   – highest 4-hour price range
   * `dext`       – closest to 24h high or low
   * `volume_15m` – highest quote volume in last 15 minutes
   * `volume_24h` – highest quote volume in last 24 hours
   * `gvolume`    – strongest volume increase: 15m vs 4h baseline

2. **Interval (global chart timeframe)**

   * `1m`, `5m`, `15m`, `1h`, `4h`, `1d`

3. **Market**

   * Fixed to `futures` for Binance USDT-M.
   * No selector UI is needed for MVP; we hard-code `futures`.

4. **Count (grid size)**

   * `4`, `9`, `16`, `25`
   * This maps to layouts: 2x2, 3x3, 4x4, 5x5.

### 2.3 Defaults on First Load ✅

* `sortMode`: `volume_24h`
* `interval`: `1h`
* `marketType`: `futures`
* `count`: `16`

The app must render the UI shell immediately with these defaults and show skeleton chart cells while data is loading.

### 2.4 Features Explicitly Out of Scope for MVP ✅

* No FocusPanel (large single-chart view) is required in the first implementation, although the file is pre-created for later.
* No authentication or subscription logic is implemented yet (only placeholders described later).
* No backend / server-side code of any kind.
* No manual symbol searching or watchlists.

---

## 3. Types and Data Models ✅

### 3.1 Basic Types ✅

Define in `src/core/types.ts`.

```ts
export type MarketType = 'futures';

export type Interval =
  | '1m'
  | '5m'
  | '15m'
  | '1h'
  | '4h'
  | '1d';

export type RangeWindow = '5m' | '15m' | '1h' | '4h';
export type VolumeWindow = '15m' | '4h' | '24h';

export type SortMode =
  | 'range_5m'
  | 'range_15m'
  | 'range_1h'
  | 'range_4h'
  | 'dext'
  | 'volume_15m'
  | 'volume_24h'
  | 'gvolume';

export interface Candle {
  symbol: string;              // 'BTCUSDT'
  interval: Interval;

  openTime: number;            // ms since epoch
  closeTime: number;           // ms since epoch

  open: number;
  high: number;
  low: number;
  close: number;

  volumeBase: number;          // contract/base volume
  volumeQuote: number | null;  // quote volume (USDT); if null, derive as close * volumeBase

  trades: number | null;       // trade count in this bar if available

  isFinal: boolean;            // true when bar is closed
}

export interface SymbolInfo {
  symbol: string;        // 'BTCUSDT'
  baseAsset: string;     // 'BTC'
  quoteAsset: string;    // 'USDT'
  marketType: MarketType;// always 'futures' here
  status: string;        // use Binance status, e.g. 'TRADING'
}

export interface RangeMetric {
  window: RangeWindow;
  high: number;
  low: number;
  abs: number;   // high - low
  pct: number;   // (high - low) / low
}

export interface VolumeMetric {
  window: VolumeWindow;  // '15m' | '4h' | '24h'
  base: number;          // summed base volume
  quote: number;         // summed quote volume, used for ranking
}

export type ExtremumSide = 'high' | 'low' | 'none';

export interface DailyExtremumMetric {
  high24h: number;
  low24h: number;
  lastPrice: number;

  distToHighPct: number; // (high24h - lastPrice) / high24h
  distToLowPct: number;  // (lastPrice - low24h) / low24h

  nearestSide: ExtremumSide; // 'high' | 'low' | 'none'
  score: number;             // min(distToHighPct, distToLowPct)
}

export interface GrowthMetric {
  currentWindow: '15m';
  baselineWindow: '4h';

  baselinePer15m: number; // baseline average per 15m
  current: number;        // current 15m value
  ratio: number;          // current / baselinePer15m
  delta: number;          // ratio - 1
}

export interface SymbolMetrics {
  symbol: string;
  marketType: MarketType; // always 'futures'

  lastPrice: number;
  lastUpdateTs: number;   // ms since epoch when metrics last updated

  ranges: {
    '5m': RangeMetric;
    '15m': RangeMetric;
    '1h': RangeMetric;
    '4h': RangeMetric;
  };

  volume: {
    '15m': VolumeMetric;
    '4h': VolumeMetric;
    '24h': VolumeMetric;
  };

  growth: {
    gVolume: GrowthMetric;
  };

  dailyExtremum: DailyExtremumMetric;

  currentSortScore?: number; // score for last-computed SortMode (for internal caching only)
}

export interface SymbolTopEntry {
  info: SymbolInfo;
  metrics: SymbolMetrics;
  sortMode: SortMode;
  sortScore: number;
}
```

### 3.2 Sort Directions ✅

When ranking symbols for a given `SortMode`:

* **Descending sort (higher = better):**

  * `range_5m`, `range_15m`, `range_1h`, `range_4h`
  * `volume_15m`, `volume_24h`
  * `gvolume` (using `ratio` or `delta`, see metrics rules)
* **Ascending sort (closer to extremum is better):**

  * `dext` (use `dailyExtremum.score`; smaller is better)

These directions are fixed and must not be changed.

---

## 4. Binance Connectivity – Frontend Only ✅

### 4.1 REST Endpoints ✅

Use Binance Futures **USDT-M** endpoints from the browser via `fetch`.

All requests go to:

* Base URL: `https://fapi.binance.com`

Endpoints used:

1. **24h Ticker** – full universe bootstrap

   ```http
   GET /fapi/v1/ticker/24hr
   ```

   * Called **without** `symbol` parameter.
   * Returns an array of tickers for all futures symbols.
   * From this we derive:

     * 24h quote volume (`quoteVolume`) → `volume_24h`
     * 24h high/low (`highPrice`, `lowPrice`) and `lastPrice` → `dext` metrics

2. **Exchange Info** – symbol metadata

   ```http
   GET /fapi/v1/exchangeInfo
   ```

   * Used to build `SymbolInfo[]` and to filter:

     * Only `USDT` quote pairs
     * Only symbols with `status === 'TRADING'`

3. **Klines** – historical candles

   ```http
   GET /fapi/v1/klines?symbol=BTCUSDT&interval=1h&limit=120
   ```

   * Used to seed candle buffers for visible symbols.
   * `limit` must be between 100 and 500; we use specific values per interval (defined later).

### 4.2 WebSocket Streams ✅

Use Binance futures **market data streams** with a single multiplexed connection.

* Base WS URL: `wss://fstream.binance.com/ws`

For klines:

* Stream name per symbol & interval: `"<symbolLower>@kline_<interval>"`.

  * Example: `"btcusdt@kline_1h"`.

The WebSocket manager (`binanceWs.ts`) must:

* Maintain **one** active `WebSocket` instance.
* Allow subscribe / unsubscribe for streams by id.
* Decode incoming kline events and forward them as `Candle` objects to the `ClientMetricsEngine`.

No other streams (trades, aggTrades, etc.) are used in the MVP.

### 4.3 Rate Limiting and Errors ✅

* On HTTP 429 or repeated network failures:

  * Set a global state flag `apiStatus = 'rate_limited' | 'error'`.
  * Show a **small banner** at the top-right: e.g. `"Binance API is rate-limiting your IP. Data may update slowly."`.
  * Implement exponential backoff for further REST calls (start with 15s, then 30s, 60s...).

* WebSocket reconnect:

  * On close or error, try to reconnect after 5 seconds.
  * On reconnect, resubscribe to all active symbol+interval streams.

---

## 5. Metrics Engine – Client Side ✅

The `ClientMetricsEngine` (in `clientEngine.ts`) is a pure TypeScript orchestrator that:

1. Uses `ClientBinanceProvider` for data access.
2. Maintains **rolling candle buffers** in memory per symbol + interval.
3. Computes `SymbolMetrics` for each tracked symbol.
4. Maintains sorted arrays per `SortMode`.
5. Exposes derived `topEntries` and metrics via Zustand store.

### 5.1 Symbol Universe and Active Set ✅

* **Universe:** all `USDT`-quoted USDT-M futures symbols with `status === 'TRADING'`.
* **Active Set:** top 100 symbols by `volume_24h` (based on 24h ticker data).

Metrics and kline history are computed **only for the Active Set**.
Symbols outside this set are ignored for MVP.

### 5.2 Candle Buffers ✅

For each **active symbol** and **interval**:

* Maintain a ring buffer of recent `Candle` objects.
* `MAX_BARS_PER_INTERVAL` (per symbol) values:

  * `1m`: 500
  * `5m`: 500
  * `15m`: 500
  * `1h`: 500
  * `4h`: 500
  * `1d`: 500

On receiving a new kline event:

* If the incoming bar matches the last candle `openTime`, **replace** it and update `isFinal` accordingly.
* If it has a later `openTime`, **append** it and drop the oldest if buffer exceeds `MAX_BARS_PER_INTERVAL`.

### 5.3 Bootstrap Load Pipeline ✅

On app start (`ClientMetricsEngine.init()`):

1. **Render shell immediately**: App Shell, TopBar, and grid of skeleton `ChartCell`s for default `count = 16`.
2. **Fetch 24h tickers** (`/fapi/v1/ticker/24hr`):

   * Filter to `USDT`-quoted, `TRADING` symbols.
   * Compute 24h volume metrics and `dext` metrics for all such symbols.
   * Determine **Active Set**: top 100 by 24h quote volume.
   * Compute initial rankings for `volume_24h` (default) and optionally `dext`.
   * Update store with available symbols & top lists → real symbol labels appear in the grid.
3. **Fetch exchangeInfo** (`/fapi/v1/exchangeInfo`):

   * Build `SymbolInfo` objects for all Active Set symbols.
4. **Seed candles for visible symbols** (default top 16):

   * For each **visible symbol** and current `interval = 1h`:

     * Call `/fapi/v1/klines` with `limit = 120`.
     * Do this in waves with a maximum of 4 concurrent requests.
   * As each symbol completes, store candles and mark that cell as ready → chart replaces skeleton.
5. **Open WebSocket connection**:

   * Subscribe to kline streams for visible symbols at current interval.
   * On every kline event:

     * Update candle buffers.
     * Recompute affected symbol metrics.
6. **Background enrichment**:

   * Gradually fetch required klines for non-visible Active Set symbols to support other SortModes and intervals.
   * Always obey concurrency limits and backoff strategy.

### 5.4 Metric Formulas ✅

Use functions in `metrics.ts`. **All metrics are time-based.**

#### 5.4.1 Range metrics

For window `W` in `{5m, 15m, 1h, 4h}` for a given symbol:

* Use candles matching the window interval directly:

  * 5m range: 5m candles
  * 15m range: 15m candles
  * 1h range: 1h candles
  * 4h range: 4h candles

* Consider all candles whose **closeTime** is within last `W` minutes.

* Compute:

  * `high_W = max(high)` over those candles
  * `low_W = min(low)` over those candles
  * `abs = high_W - low_W`
  * `pct = (high_W - low_W) / low_W`

If there is not enough candle data for a window, set metrics to `0` and mark them as `inactive = true` internally; such symbols will naturally sort to the bottom.

#### 5.4.2 Volume metrics

For each window `V` in `{15m, 4h, 24h}`:

* Using the appropriate interval candles:

  * 15m window: 15m candles
  * 4h window: 4h candles
  * 24h window: can be approximated with 1h candles or directly from ticker:

    * For MVP, **use 24h ticker's `quoteVolume`** for `volume_24h.quote` and `volume_24h.base` (if applicable).

* For 15m and 4h windows:

  * Use candles whose **closeTime** is within the window.
  * For each candle:

    * Let `base = volumeBase`
    * Let `quote = candle.volumeQuote ?? candle.close * candle.volumeBase`
  * Sum all:

    * `volume.base = Σ base`
    * `volume.quote = Σ quote`

#### 5.4.3 Daily extremum metrics (dExt)

Use ticker fields:

* `high24h = highPrice`
* `low24h = lowPrice`
* `lastPrice = lastPrice`

Compute:

* `distToHighPct = (high24h - lastPrice) / high24h`
* `distToLowPct = (lastPrice - low24h) / low24h`

Set:

* If both distances are > 0:

  * If `distToHighPct < distToLowPct` → `nearestSide = 'high'`
  * Else → `nearestSide = 'low'`
  * `score = min(distToHighPct, distToLowPct)`
* If data is invalid, `nearestSide = 'none'` and `score = Number.POSITIVE_INFINITY`.

#### 5.4.4 Growth metrics – `gvolume`

Baseline window: 4h.

* `volume_4h.quote` is computed as above.
* `volume_15m.quote` is computed as above.

Compute per symbol:

* `baselinePer15m = volume_4h.quote / 16`  (since 4h = 16 × 15m)
* If `baselinePer15m <= 0`, set:

  * `ratio = 0`
  * `delta = 0`
* Else:

  * `ratio = volume_15m.quote / baselinePer15m`
  * `delta = ratio - 1`

For sorting `gvolume`:

* Use `ratio` as the primary `sortScore`.

### 5.5 Ranking Logic ✅

`ranking.ts` exposes a pure function:

```ts
export function computeRankings(
  metricsBySymbol: Record<string, SymbolMetrics>
): Record<SortMode, SymbolTopEntry[]>;
```

For each `SortMode`, it:

* Computes `sortScore` from the relevant metric fields
* Sorts the `SymbolMetrics` list in the correct direction
* Returns `SymbolTopEntry[]` with `info`, `metrics`, `sortMode`, `sortScore`.

This function must **never** depend on React or browser APIs.

The engine recomputes rankings at most once every 2 seconds (or on an explicit timer), not on every incoming kline event, to avoid excessive CPU usage.

---

## 6. Global State Model (Zustand) ✅

`useZeroLagStore.ts` defines a single Zustand store with the following shape:

```ts
interface ZeroLagState {
  // Controls
  sortMode: SortMode;
  interval: Interval;
  count: 4 | 9 | 16 | 25;

  // System status
  apiStatus: 'ok' | 'rate_limited' | 'error';
  wsConnected: boolean;

  // Symbol data
  symbols: Record<string, SymbolInfo>;      // by symbol
  activeSymbols: string[];                  // top 100 by volume_24h

  // Metrics & rankings
  metricsBySymbol: Record<string, SymbolMetrics>;
  rankings: Record<SortMode, SymbolTopEntry[]>;

  // Derived selectors (implemented via getters/helpers, not stored twice)
  // - visibleSymbols

  // Actions
  setSortMode(mode: SortMode): void;
  setInterval(interval: Interval): void;
  setCount(count: 4 | 9 | 16 | 25): void;

  setApiStatus(status: ZeroLagState['apiStatus']): void;
  setWsConnected(connected: boolean): void;

  setSymbols(symbols: Record<string, SymbolInfo>): void;
  setActiveSymbols(symbols: string[]): void;

  upsertMetrics(symbol: string, metrics: SymbolMetrics): void;
  setRankings(rankings: Record<SortMode, SymbolTopEntry[]>): void;
}
```

`visibleSymbols` is derived as the first `count` entries from `rankings[sortMode]`.

The `ClientMetricsEngine` owns **when** these setters are called; React components only read state and trigger the high-level control setters.

---

## 7. UI and Visual Design ✅

### 7.1 General Theme ✅

* **Dark, minimal, functional**.
* Layout resembles a **calm radar console** rather than a flashy trading platform.

### 7.2 Color Tokens (Tailwind via CSS variables) ✅

Define in `index.css` root:

```css
:root {
  --bg-page: #05060a;
  --bg-panel: #0c0f18;
  --bg-panel-soft: #10131d;
  --border-subtle: #181c28;
  --grid-lines: #191d28;
  --text-main: #e7edf7;
  --text-muted: #767c8f;
  --text-soft: #505568;

  --accent-cyan: #1cd0f9;
  --accent-blue: #3c82ff;
  --accent-amber: #f6b44d;
  --accent-red: #f25e72;

  --candle-up: #1fd39a;
  --candle-down: #f45b6c;
}
```

Use Tailwind with these variables, e.g. `bg-[color:var(--bg-panel)]`.

### 7.3 Typography ✅

* Base font: `Inter` or `DM Sans` (pick one and use it consistently).
* Base size: `14px`.
* Chart metric strip: `11–12px`.
* Big symbol watermark: `26–32px`, very low opacity.

Font weights:

* 500 for control labels
* 600 for active pills
* 400 or 300 for muted labels

### 7.4 Layout ✅

* Outer page: full-screen, `bg-page`.

* AppShell:

  * Padding: 24px on desktop.
  * Flex column: TopBar at top, Grid fills remaining height with `overflow: auto`.

* TopBar:

  * Height: 48–56px.
  * Background: `bg-panel-soft` with bottom border `border-subtle`.
  * Three sections:

    * Left: SortSelector
    * Center: IntervalSelector
    * Right: CountSelector + status indicators (`REST`, `WS`).

* Grid:

  * Gap between cells: 12–16px.
  * Each `ChartCell` card:

    * Background: `bg-panel` with a very subtle gradient `linear-gradient(135deg,#0c0f18,#090b12)`.
    * Border: `1px solid var(--border-subtle)`.
    * Border-radius: `10px`.
    * Padding top: 12px; sides: 8px; bottom: 6px.
    * On hover:

      * Slight translation `translateY(-1px)`.
      * Border color changes to a soft `accent-blue` with glow: `box-shadow: 0 0 18px rgba(60,130,255,0.25)`.

### 7.5 ChartCell Structure ✅

Each `ChartCell` contains three visible zones:

1. **Header row (top strip):**

   * Left side:

     * `symbol` (e.g. `BTCUSDT`) in small text.
     * Tiny badge `F` for futures (static).
   * Right side:

     * A short label summarizing the current sort metric for that symbol.

       * Example for `volume_24h`: `"24h Vol 1.6B"`.
       * Example for `dext`: `"▲ 1.2% from high"` or `"▼ 0.8% from low"` depending on `nearestSide`.

2. **Main chart area:**

   * uPlot canvas for price candles.
   * Volume bars in a small lower band.
   * Crosshair line on hover.
   * Grid: only horizontal lines in `grid-lines` color, no verticals.
   * Y-axis labels can be hidden in grid mode for minimalism.

3. **Background watermark:**

   * Centered symbol base (e.g. `BTC`) as large subtle text behind chart content.
   * Color: `rgba(255, 255, 255, 0.04)`.

Optional (later, not required for first working version): a bottom micro-metrics row.

### 7.6 Status Indicators ✅

TopBar right side shows REST/WS status:

* Two small text labels: `REST`, `WS`.
* Next to each, a dot:

  * Green when `apiStatus === 'ok'` or `wsConnected === true`.
  * Yellow or red when degraded.

A separate small banner appears at top-right in case of rate limit or error.

---

## 8. Chart Implementation (uPlot) ✅

`TimeSeriesCandleChart.tsx` wraps uPlot.

### 8.1 Props ✅

```ts
interface TimeSeriesCandleChartProps {
  candles: Candle[];     // already filtered & ordered by openTime
  width: number;
  height: number;
}
```

Responsibility of the parent (`ChartCell`) is to pass correct width & height (using a resize observer if needed).

### 8.2 Data Conversion ✅

Inside the wrapper:

* Build arrays:

  * `t[]`: timestamps (ms or seconds; be consistent)
  * `open[]`, `high[]`, `low[]`, `close[]`
  * `volume[]`

* Feed into uPlot series configuration for:

  * Candle series: OHLC
  * Volume series: separate y-scale and lower band.

### 8.3 Styling in uPlot ✅

* Chart background: transparent; let parent card background show.
* Grid: only horizontal lines, color `var(--grid-lines)`, width 1px.
* Axes:

  * X-axis labels can be disabled for mini charts.
  * Y-axis labels can be disabled or shown with very small font; we prefer disabled in grid view.
* Candles:

  * Up candles: `var(--candle-up)` for body and wick.
  * Down candles: `var(--candle-down)` for body and wick.
  * Thin bodies and wicks so dense data still looks clean.
* Volume:

  * Bars with low opacity; color-coded by up/down direction of candle.

### 8.4 Live Updates ✅

When new candle data arrives from WebSocket or REST:

* Update the local `candles` array in Zustand store.
* `TimeSeriesCandleChart` must respond by updating uPlot data via `u.setData()` rather than recreating the entire chart.

---

## 9. Ruler Interaction (Shift-Measure Tool) ✅

The app must support a **ruler tool** when the user holds the `Shift` key over a chart.

Implementation rules:

* This applies **at least** in grid view. A future FocusPanel can reuse the same logic with extended labels.

### 9.1 Interaction Flow ✅

1. **Normal mode (no Shift pressed):**

   * Hovering shows a standard crosshair (if enabled in uPlot) but **no ruler**.

2. **Entering measure mode:**

   * When user holds `Shift` and clicks once on a chart:

     * Set anchor point **A** at the nearest candle to the click.
     * Store anchor index and price.

3. **Dragging in measure mode:**

   * While `Shift` is still pressed and the pointer moves:

     * Determine current point **B** (nearest candle to pointer).
     * Draw a straight line from A → B over the chart.
     * Draw a small `Δ` info box in a fixed corner of the chart showing:

       * `ΔPrice` (absolute difference)
       * `Δ%` relative to anchor price
       * `ΔBars` (number of candles between A and B)

4. **Fixing / clearing ruler:**

   * Second click while still holding `Shift`:

     * Fixes the ruler but continues to show it until `Shift` is released or `Esc` is pressed.
   * On `Shift` keyup **or** `Esc` key press:

     * Clear the ruler state and return to normal hover mode.

### 9.2 Implementation Notes ✅

* Manage ruler state **per ChartCell**, not globally.
* You can use an absolutely positioned `<canvas>` or `<svg>` overlay above uPlot for drawing the line and labels, or you can draw inside uPlot via hooks. Choose one approach and apply consistently.
* Do not allow the ruler to affect global app state; it is local UI state only.

---

## 10. Skeleton Loading and Perceived Performance ✅

To keep the app feeling instant:

1. **Shell first:** Render AppShell, TopBar, and an empty grid with 16 `ChartSkeleton` components immediately (before any network call resolves).
2. **After 24h ticker resolves:**

   * Replace skeleton labels with real symbols and basic 24h metrics for visible symbols, but keep chart skeletons until klines arrive.
3. **As each symbol's klines arrive:**

   * Replace skeleton chart with real uPlot chart one by one.

`ChartSkeleton` must visually mimic card layout but with animated skeleton bars or shimmer.

---

## 11. Extensibility and Non-Implemented Features (Placeholders)

Even though no backend or subscription system exists yet, the code should be **ready** for it:

1. **Feature Flags:**

   * Create a simple `featureFlags` object in `useZeroLagStore` or a separate module:

     ```ts
     export const featureFlags = {
       maxCountFree: 16 as 4 | 9 | 16 | 25,
       // In future, we can lower this for free users and unlock 25+ for paid
     };
     ```

   * Use this to gate which `count` options are selectable.

2. **API Layer Abstraction:**

   * Encapsulate all Binance calls inside `ClientBinanceProvider` with the same method signatures a future backend would expose (e.g. `listSymbols`, `getHistoricalCandles`).
   * Later, these methods can be swapped to call our own backend without changing UI or MetricsEngine.

3. **FocusPanel Placeholder:**

   * Implement a minimal `FocusPanel` component that is not yet wired, or keep the file empty but with a clear TODO header.

---

## 12. Implementation Order

1. ✅ **Scaffold project** with Vite + React + TS + Tailwind + Zustand.
2. ✅ Implement `core/types.ts`, `metrics.ts`, and `ranking.ts` as pure logic.
3. ✅ Implement `useZeroLagStore` with controls and symbol/metrics placeholders.
4. ✅ Implement `ClientBinanceProvider` (`binanceRest.ts`, `binanceWs.ts`, `clientProvider.ts`) with real Binance REST + WS calls.
5. ✅ Implement `ClientMetricsEngine` with:

   * Bootstrap pipeline
   * Candle buffers
   * Periodic metrics computation
   * Rankings update into store
6. ✅ Implement UI shell:

   * `AppShell`, `TopBar`, `SortSelector`, `IntervalSelector`, `CountSelector`.
   * `ChartGrid`, `ChartCell`, `ChartSkeleton`.
7. ⚠️ Integrate `TimeSeriesCandleChart` using uPlot. (Implemented as `MiniChart` using Canvas)
8. ❌ Implement Shift-ruler overlay.
9. ❌ Test on different counts (4, 9, 16, 25) and intervals to ensure performance.

All future additions (backend, subscriptions, FocusPanel, more SortModes) must preserve this architecture and type contracts unless this document is explicitly updated.
